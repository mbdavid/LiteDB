<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LiteDB</name>
    </assembly>
    <members>
        <member name="M:LiteDB.LiteCollection`1.Count">
            <summary>
            Get document count using property on collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(LiteDB.Query)">
            <summary>
            Count documnets with a query. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Count documnets with a query. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(LiteDB.Query)">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min(System.String)">
            <summary>
            Returns the first/min value from a index field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min">
            <summary>
            Returns the first/min _id field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Returns the first/min field using a linq expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max(System.String)">
            <summary>
            Returns the last/max value from a index field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max">
            <summary>
            Returns the last/max _id field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Returns the last/max field using a linq expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.InsertBulk(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Bulk documents to a collection - use data chunks for most efficient insert
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Run an include action in each document returned by Find(), FindById(), FindOne() and All() methods to load DbRef documents
            Returns a new Collection with this action included
            </summary>
        </member>
        <member name="P:LiteDB.LiteCollection`1.Name">
            <summary>
            Get collection name
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(LiteDB.Query)">
            <summary>
            Remove all document based on a Query object. Returns removed document counts
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Remove all document based on a LINQ query. Returns removed document counts
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(LiteDB.BsonValue)">
            <summary>
            Remove an document in collection using Document Id - returns false if not found document
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex(System.String,LiteDB.IndexOptions)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already. Returns true if index was created or false if already exits
            </summary>
            <param name="field">Document field name (case sensitive)</param>
            <param name="options">All index options</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex(System.String,System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already. Returns true if index was created or false if already exits
            </summary>
            <param name="field">Document field name (case sensitive)</param>
            <param name="unique">All index options</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already.
            </summary>
            <param name="property">Property linq expression</param>
            <param name="unique">Create a unique values index?</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},LiteDB.IndexOptions)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already.
            </summary>
            <param name="property">Property linq expression</param>
            <param name="options">Use all indexes options</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.GetIndexes">
            <summary>
            Returns all indexes in this collections
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DropIndex(System.String)">
            <summary>
            Drop index and release slot for another index
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Find(LiteDB.Query,System.Int32,System.Int32)">
            <summary>
            Find documents inside a collection using Query object. Must have indexes in query expression 
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Find(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.Int32,System.Int32)">
            <summary>
            Find documents inside a collection using Linq expression. Must have indexes in linq expression 
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindById(LiteDB.BsonValue)">
            <summary>
            Find a document using Document Id. Returns null if not found.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(LiteDB.Query)">
            <summary>
            Find the first document using Query object. Returns null if not found. Must have index on query expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Find the first document using Linq expression. Returns null if not found. Must have indexes on predicate.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindAll">
            <summary>
            Returns all documents inside collection order by _id index.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(`0)">
            <summary>
            Insert a new document to this collection. Document Id must be a new value in collection - Returns document Id
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert an array of new documents to this collection. Document Id must be a new value in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.GetBsonDocs(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Convert each T document in a BsonDocument, setting autoId for each one
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(`0)">
            <summary>
            Update a document in this collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(LiteDB.BsonValue,`0)">
            <summary>
            Update a document in this collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(LiteDB.Query,System.Action{`0})">
            <summary>
            Query documents and execute, for each document, action method. After action, update each document
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.Action{`0})">
            <summary>
            Query documents and execute, for each document, action method. All data is locked during execution
            </summary>
        </member>
        <member name="T:LiteDB.DbEngine">
            <summary>
            A internal class that take care of all engine data structure access - itÂ´s basic implementation of a NoSql database
            Its isolated from complete solution - works on low level only
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Shrink">
            <summary>
            Copy database do another disk
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.DumpPages(System.UInt32,System.UInt32)">
            <summary>
            Dump all pages into a string - debug purpose only
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.DumpIndex(System.String,System.String,System.Int32)">
            <summary>
            Dump skip list to a human reable format - debug purpose only
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.DeleteDocuments(System.String,LiteDB.Query)">
            <summary>
            Implements delete based on a query result
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Find(System.String,LiteDB.Query,System.Int32,System.Int32)">
            <summary>
            Find for documents in a collection using Query definition
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.EnsureIndex(System.String,System.String,LiteDB.IndexOptions)">
            <summary>
            Create a new index (or do nothing if already exisits) to a collection/field
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.DropIndex(System.String,System.String)">
            <summary>
            Drop an index from a collection
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.GetIndexes(System.String)">
            <summary>
            List all indexes inside a collection
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.GetCollectionNames">
            <summary>
            Returns all collection inside datafile
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.DropCollection(System.String)">
            <summary>
            Drop collection including all documents, indexes and extended pages
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.RenameCollection(System.String,System.String)">
            <summary>
            Rename a collection
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Min(System.String,System.String)">
            <summary>
            Returns first value from an index (first is min value)
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Max(System.String,System.String)">
            <summary>
            Returns last value from an index (last is max value)
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Count(System.String,LiteDB.Query)">
            <summary>
            Count all nodes from a query execution - do not deserialize documents to count
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Exists(System.String,LiteDB.Query)">
            <summary>
            Check if has at least one node in a query execution - do not deserialize documents to check
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.UpdateDocuments(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument})">
            <summary>
            Implement update command to a document inside a collection
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.InsertDocuments(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument})">
            <summary>
            Implements insert documents in a collection
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.GetCollectionPage(System.String,System.Boolean)">
            <summary>
            Get the collection page only when nedded. Gets from pager always to garantee that wil be the last (in case of clear cache will get a new one - pageID never changes)
            </summary>
        </member>
        <member name="M:LiteDB.DbEngine.Transaction``1(System.String,System.Boolean,System.Func{LiteDB.CollectionPage,``0})">
            <summary>
            Encapsulate all transaction commands in same data structure
            </summary>
        </member>
        <member name="T:LiteDB.StreamDiskService">
            <summary>
            A simple implementation of diskservice using base Stream (no journal, thread safe)
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.Initialize">
            <summary>
            Checks only if stream is empty
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.Lock">
            <summary>
            Lock stream
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.Unlock">
            <summary>
            Release lock
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.GetChangeID">
            <summary>
            Read first 2 bytes from datafile - contains changeID (avoid to read all header page)
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.ReadPage(System.UInt32)">
            <summary>
            Read page bytes from disk
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.WritePage(System.UInt32,System.Byte[])">
            <summary>
            Persist single page bytes to disk
            </summary>
        </member>
        <member name="T:LiteDB.EmptyPage">
            <summary>
            Represent a empty page (reused)
            </summary>
        </member>
        <member name="P:LiteDB.EmptyPage.PageType">
            <summary>
            Page type = Empty
            </summary>
        </member>
        <member name="M:LiteDB.EmptyPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="T:LiteDB.BsonReader">
            <summary>
            Internal class to deserialize a byte[] into a BsonDocument using BSON data format
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.Deserialize(System.Byte[])">
            <summary>
            Main method - deserialize using ByteReader helper
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadDocument(LiteDB.ByteReader)">
            <summary>
            Read a BsonDocument from reader
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadArray(LiteDB.ByteReader)">
            <summary>
            Read an BsonArray from reader
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadElement(LiteDB.ByteReader,System.String@)">
            <summary>
            Reads an element (key-value) from an reader
            </summary>
        </member>
        <member name="T:LiteDB.BsonSerializer">
            <summary>
            Class to call method for convert BsonDocument to/from byte[] - based on http://bsonspec.org/spec.html
            </summary>
        </member>
        <member name="T:LiteDB.BsonWriter">
            <summary>
            Internal class to serialize a BsonDocument to BSON data format (byte[])
            </summary>
        </member>
        <member name="M:LiteDB.BsonWriter.Serialize(LiteDB.BsonDocument)">
            <summary>
            Main method - serialize document. Uses ByteWriter
            </summary>
        </member>
        <member name="M:LiteDB.BsonWriter.WriteDocument(LiteDB.ByteWriter,LiteDB.BsonDocument)">
            <summary>
            Write a bson document
            </summary>
        </member>
        <member name="T:LiteDB.EntityBuilder`1">
            <summary>
            Helper class to modify your entity mapping to document. Can be used instead attribute decorates
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Ignore``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Define which property will not be mapped to document
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Define a custom name for a property when mapping to document
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Key``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Define which property is your document id (primary key). Define if this property supports auto-id
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Index``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Define an index based in a field on entity
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Index``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},LiteDB.IndexOptions)">
            <summary>
            Define an index based in a field on entity
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.DbRef``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Define a subdocument (or a list of) as a reference
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.RegisterDbRef(LiteDB.PropertyMapper,System.String,System.Type,System.Collections.Generic.Dictionary{System.String,LiteDB.PropertyMapper})">
            <summary>
            Register a property as a DbRef - implement a custom Serialize/Deserialize actions to convert entity to $id, $ref only 
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.RegisterDbRefList(LiteDB.PropertyMapper,System.String,System.Type,System.Type,System.Collections.Generic.Dictionary{System.String,LiteDB.PropertyMapper})">
            <summary>
            Register a property as a DbRefList - implement a custom Serialize/Deserialize actions to convert entity to $id, $ref only 
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{LiteDB.PropertyMapper})">
            <summary>
            Get a property based on a expression. Eg.: 'x => x.UserId' return string "UserId"
            </summary>
        </member>
        <member name="T:LiteDB.ObjectId">
            <summary>
            Represent a 12-bytes BSON type used in document Id
            </summary>
        </member>
        <member name="F:LiteDB.ObjectId.Empty">
            <summary>
            A zero 12-bytes ObjectId
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Timestamp">
            <summary>
            Get timestamp
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Machine">
            <summary>
            Get machine number
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Pid">
            <summary>
            Get pid number
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Increment">
            <summary>
            Get increment
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.CreationTime">
            <summary>
            Get creation time
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor">
            <summary>
            Initializes a new empty instance of the ObjectId class.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.Int32,System.Int32,System.Int16,System.Int32)">
            <summary>
            Initializes a new instance of the ObjectId class from ObjectId vars.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(LiteDB.ObjectId)">
            <summary>
            Initializes a new instance of ObjectId class from another ObjectId.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ObjectId class from hex string.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the ObjectId class from byte array.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.FromHex(System.String)">
            <summary>
            Convert hex value string in byte array
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.Equals(LiteDB.ObjectId)">
            <summary>
            Equalses the specified other.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to this instance.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.CompareTo(LiteDB.ObjectId)">
            <summary>
            Compares two instances of ObjectId
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.ToByteArray">
            <summary>
            Represent ObjectId as 12 bytes array
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.NewObjectId">
            <summary>
            Creates a new ObjectId.
            </summary>
        </member>
        <member name="T:LiteDB.QueryContains">
            <summary>
            Contains query do not work with index, only full scan
            </summary>
        </member>
        <member name="T:LiteDB.QueryVisitor`1">
            <summary>
            Class helper to create Queries based on Linq expressions
            </summary>
        </member>
        <member name="M:LiteDB.QueryVisitor`1.GetBsonField``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Get a Bson field from a simple Linq expression: x => x.CustomerName
            </summary>
        </member>
        <member name="M:LiteDB.QueryVisitor`1.GetBsonField(System.String)">
            <summary>
            Get a bson string field based on class PropertyInfo using BsonMapper class
            Support Name1.Name2 dotted notation
            </summary>
        </member>
        <member name="M:LiteDB.QueryVisitor`1.GetTypeField(System.Type,System.String,System.Type@)">
            <summary>
            Get a field name passing mapper type and returns property type
            </summary>
        </member>
        <member name="T:LiteDB.QueryNot">
            <summary>
            Not is an Index Scan operation
            </summary>
        </member>
        <member name="T:LiteDB.QueryAll">
            <summary>
            All is an Index Scan operation
            </summary>
        </member>
        <member name="T:LiteDB.JsonReader">
            <summary>
            A class that read a json string using a tokenizer (without regex)
            </summary>
        </member>
        <member name="T:LiteDB.JsonTokenizer">
            <summary>
            Class that parse a json string and returns in json token
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.Read">
            <summary>
            Read next char in stream and set in _current
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadToken">
            <summary>
            Read next json token
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.EatWhitespace">
            <summary>
            Eat all whitespaces - used before a valid token
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadWord">
            <summary>
            Read a word without "
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadNumber">
            <summary>
            Read a number - it's accepts all number char, but not validate. When run Convert, .NET will check if number is correct
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadString">
            <summary>
            Read a string removing open and close "
            </summary>
        </member>
        <member name="T:LiteDB.BsonIgnoreAttribute">
            <summary>
            Indicate that property will not be persist in Bson serialization
            </summary>
        </member>
        <member name="T:LiteDB.BsonIdAttribute">
            <summary>
            Indicate that property will be used as BsonDocument Id
            </summary>
        </member>
        <member name="P:LiteDB.LiteFileStream.FileInfo">
            <summary>
            Get file information
            </summary>
        </member>
        <member name="T:LiteDB.LiteFileInfo">
            <summary>
            Represets a file inside storage collection
            </summary>
        </member>
        <member name="F:LiteDB.LiteFileInfo.ID_PATTERN">
            <summary>
            File id have a specific format - it's like file path.
            </summary>
        </member>
        <member name="F:LiteDB.LiteFileInfo.CHUNK_SIZE">
            <summary>
            Number of bytes on each chunk document to store
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.GetChunckId(System.String,System.Int32)">
            <summary>
            Returns chunck Id for a file
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.OpenRead">
            <summary>
            Open file stream to read from database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.SaveAs(System.String,System.Boolean)">
            <summary>
            Save file content to a external file
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.CopyTo(System.IO.Stream)">
            <summary>
            Copy file content to another stream
            </summary>
        </member>
        <member name="T:LiteDB.LiteFileStorage">
            <summary>
            Storage is a special collection to store files/streams.
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.Upload(LiteDB.LiteFileInfo,System.IO.Stream)">
            <summary>
            Insert a new file content inside datafile in _files collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.Upload(System.String)">
            <summary>
            Upload a file to FileStorage using Path.GetFilename as file Id
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.SetMetadata(System.String,LiteDB.BsonDocument)">
            <summary>
            Update metada on a file. File must exisits
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.Download(System.String,System.IO.Stream)">
            <summary>
            Copy all file content to a steam
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.OpenRead(System.String)">
            <summary>
            Load data inside storage and returns as Stream
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.OpenRead(LiteDB.LiteFileInfo)">
            <summary>
            Load data inside storage and returns as Stream
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.FindById(System.String)">
            <summary>
            Find a file inside datafile and returns FileEntry instance. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.Find(System.String)">
            <summary>
            Returns all FileEntry founded starting with id passed.
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.Exists(System.String)">
            <summary>
            Returns if a file exisits in database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.FindAll">
            <summary>
            Returns all FileEntry inside database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStorage.Delete(System.String)">
            <summary>
            Delete a file inside datafile and all metadata related
            </summary>
        </member>
        <member name="T:LiteDB.Query">
            <summary>
            Class helper to create query using indexes in database. All methods are statics.
            Queries can be executed in 2 ways: Index Seek (fast), Index Scan (good)
            </summary>
        </member>
        <member name="F:LiteDB.Query.Ascending">
            <summary>
            Indicate when a query must execute in ascending order
            </summary>
        </member>
        <member name="F:LiteDB.Query.Descending">
            <summary>
            Indicate when a query must execute in descending order
            </summary>
        </member>
        <member name="M:LiteDB.Query.All(System.Int32)">
            <summary>
            Returns all documents using _id index order
            </summary>
        </member>
        <member name="M:LiteDB.Query.All(System.String,System.Int32)">
            <summary>
            Returns all documents using field index order
            </summary>
        </member>
        <member name="M:LiteDB.Query.EQ(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are equals to value (=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.LT(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are less than value (&lt;)
            </summary>
        </member>
        <member name="M:LiteDB.Query.LTE(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are less than or equals value (&lt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.GT(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all document that value are greater than value (&gt;)
            </summary>
        </member>
        <member name="M:LiteDB.Query.GTE(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are greater than or equals value (&gt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Between(System.String,LiteDB.BsonValue,LiteDB.BsonValue)">
            <summary>
            Returns all document that values are between "start" and "end" values (BETWEEN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.StartsWith(System.String,System.String)">
            <summary>
            Returns all documents that starts with value (LIKE)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Contains(System.String,System.String)">
            <summary>
            Returns all documents that contains value (CONTAINS)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Not(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that are not equals to value
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,LiteDB.BsonArray)">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,LiteDB.BsonValue[])">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.And(LiteDB.Query,LiteDB.Query)">
            <summary>
            Returns document that exists in BOTH queries results (Intersect).
            </summary>
        </member>
        <member name="M:LiteDB.Query.Or(LiteDB.Query,LiteDB.Query)">
            <summary>
            Returns documents that exists in ANY queries results (Union).
            </summary>
        </member>
        <member name="M:LiteDB.Query.ExecuteIndex(LiteDB.IndexService,LiteDB.CollectionIndex)">
            <summary>
            Abstract method that must be implement for index seek/scan - Returns IndexNodes that match with index
            </summary>
        </member>
        <member name="M:LiteDB.Query.Run(LiteDB.CollectionPage,LiteDB.IndexService)">
            <summary>
            Find witch index will be used and run Execute method
            </summary>
        </member>
        <member name="T:LiteDB.BsonValue">
            <summary>
            Represent a Bson Value used in BsonDocument
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.Null">
            <summary>
            Represent a Null bson type
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.MinValue">
            <summary>
            Represent a MinValue bson type
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.MaxValue">
            <summary>
            Represent a MaxValue bson type
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.Type">
            <summary>
            Indicate BsonType of this BsonValue
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.RawValue">
            <summary>
            Get internal .NET value object
            </summary>
        </member>
        <member name="M:LiteDB.BsonValue.GetBytesCount(System.Boolean)">
            <summary>
            Returns how many bytes this BsonValue will use to persist in index writes
            </summary>
        </member>
        <member name="M:LiteDB.BsonValue.Normalize(LiteDB.IndexOptions)">
            <summary>
            Normalize a string value using IndexOptions and returns a new BsonValue - if is not a string, returns some BsonValue instance
            </summary>
        </member>
        <member name="T:LiteDB.BsonType">
            <summary>
            All supported BsonTypes in sort order
            </summary>
        </member>
        <member name="P:LiteDB.BsonDocument.Item(System.String)">
            <summary>
            Get/Set a field for document. Fields are case sensitive
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Add(System.String,LiteDB.BsonValue)">
            <summary>
            Add fields in fluent api
            </summary>
        </member>
        <member name="P:LiteDB.BsonDocument.Keys">
            <summary>
            Returns all object keys with _id in first order
            </summary>
        </member>
        <member name="P:LiteDB.BsonDocument.Count">
            <summary>
            Returns how many fields this object contains
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.ContainsKey(System.String)">
            <summary>
            Returns if object contains a named property
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.RemoveKey(System.String)">
            <summary>
            Remove a specific key on object
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.IsValidFieldName(System.String)">
            <summary>
            Test if field name is a valid string: only \w+(\w-)*
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Get(System.String)">
            <summary>
            Get value from a path - supports dotted path like: Customer.Address.Street
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Set(System.String,LiteDB.BsonValue)">
            <summary>
            Set value to a path - supports dotted path like: Customer.Address.Street - Fluent API (returns same BsonDocument)
            </summary>
        </member>
        <member name="T:LiteDB.JsonSerializer">
            <summary>
            Static class for serialize/deserialize BsonDocuments into json extended format
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a String
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a TextWriter
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(System.String)">
            <summary>
            Deserialize a Json string into a BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(System.IO.TextReader)">
            <summary>
            Deserialize a Json TextReader into a BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.DeserializeArray(System.String)">
            <summary>
            Deserialize a json array as an IEnumerable of BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.DeserializeArray(System.IO.TextReader)">
            <summary>
            Deserialize a json array as an IEnumerable of BsonValue reading on demand TextReader
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(LiteDB.StringScanner)">
            <summary>
            Deserialize a json using a StringScanner and returns BsonValue
            </summary>
        </member>
        <member name="T:LiteDB.BsonMapper">
            <summary>
            Class that converts your entity class to/from BsonDocument
            If you prefer use a new instance of BsonMapper (not Global), be sure cache this instance for better performance 
            Serialization rules:
                - Classes must be "public" with a public constructor (without parameters)
                - Properties must have public getter (can be read-only)
                - Entity class must have Id property, [ClassName]Id property or [BsonId] attribute
                - No circular references
                - Fields are not valid
                - IList, Array supports
                - IDictionary supports (Key must be a simple datatype - converted by ChangeType)
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._mapper">
            <summary>
            Mapping cache between Class/BsonDocument
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._customSerializer">
            <summary>
            Map serializer/deserialize for custom types
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._autoId">
            <summary>
            Map for autoId type based functions
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolvePropertyName">
            <summary>
            A resolver name property
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.SerializeNullValues">
            <summary>
            Indicate that mapper do not serialize null values
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.TrimWhitespace">
            <summary>
            Apply .Trim() in strings
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.EmptyStringToNull">
            <summary>
            Convert EmptyString to Null
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.Global">
            <summary>
            Global BsonMapper instance
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterType``1(System.Func{``0,LiteDB.BsonValue},System.Func{LiteDB.BsonValue,``0})">
            <summary>
            Register a custom type serializer/deserialize function
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterAutoId``1(System.Func{``0,System.Boolean},System.Func{LiteDB.LiteCollection{LiteDB.BsonDocument},``0})">
            <summary>
            Register a custom Auto Id generator function for a type
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.SetAutoId(System.Object,LiteDB.LiteCollection{LiteDB.BsonDocument})">
            <summary>
            Set new Id in entity class if entity needs one
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Entity``1">
            <summary>
            Map your entity class to BsonDocument using fluent API
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetPropertyMapper(System.Type)">
            <summary>
            Get property mapper between typed .NET class and BsonDocument - Cache results
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetIndexFromMapper``1(System.String)">
            <summary>
            Search for [BsonIndex]/Entity.Index() in PropertyMapper. If not found, returns null
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToDocument(System.Object)">
            <summary>
            Serialize a entity class to BsonDocument
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Serialize(System.Object)">
            <summary>
            Create a instance of a object convered in BsonValue object.
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToObject``1(LiteDB.BsonDocument)">
            <summary>
            Deserialize a BsonDocument to entity class
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Deserialize``1(LiteDB.BsonValue)">
            <summary>
            Deserialize an BsonValue to .NET object typed in T
            </summary>
        </member>
        <member name="T:LiteDB.BsonFieldAttribute">
            <summary>
            Set a name to this property in BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.BsonIndexAttribute">
            <summary>
            Add an index in this entity property.
            </summary>
        </member>
        <member name="P:LiteDB.AutoId.IsEmpty">
            <summary>
            Function to test if type is empty
            </summary>
        </member>
        <member name="P:LiteDB.AutoId.NewId">
            <summary>
            Function that implements how generate a new Id for this type
            </summary>
        </member>
        <member name="T:LiteDB.PropertyMapper">
            <summary>
            Internal representation for a .NET Property mapped to BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.Reflection">
            <summary>
            Helper class to get entity properties and map as BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.GetIdProperty(System.Type)">
            <summary>
            Gets PropertyInfo that refers to Id from a document object.
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.GetProperties(System.Type,System.Func{System.String,System.String})">
            <summary>
            Read all properties from a type - store in a static cache - exclude: Id and [BsonIgnore]
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.CreateInstance(System.Type)">
            <summary>
            Create a new instance from a Type
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.IsList(System.Type)">
            <summary>
            Returns true if Type is any kind of Array/IList/ICollection/....
            </summary>
        </member>
        <member name="M:LiteDB.Shell.Commands.BaseCollection.ReadCollection(LiteDB.LiteDatabase,LiteDB.StringScanner)">
            <summary>
            Read collection name from db.(colname).(command)
            </summary>
        </member>
        <member name="M:LiteDB.Shell.Commands.BaseFileStorage.ReadId(LiteDB.StringScanner)">
            <summary>
            Read Id file
            </summary>
        </member>
        <member name="T:LiteDB.DataPage">
            <summary>
            The DataPage thats stores object data.
            </summary>
        </member>
        <member name="P:LiteDB.DataPage.PageType">
            <summary>
            Page type = Extend
            </summary>
        </member>
        <member name="F:LiteDB.DataPage.DATA_RESERVED_BYTES">
            <summary>
            If a Data Page has less that free space, it's considered full page for new items. Can be used only for update (DataPage) ~ 50% PAGE_AVAILABLE_BYTES
            This value is used for minimize 
            </summary>
        </member>
        <member name="P:LiteDB.DataPage.DataBlocks">
            <summary>
            Returns all data blocks - Each block has one object
            </summary>
        </member>
        <member name="M:LiteDB.DataPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="P:LiteDB.IndexPage.PageType">
            <summary>
            Page type = Index
            </summary>
        </member>
        <member name="F:LiteDB.IndexPage.INDEX_RESERVED_BYTES">
            <summary>
            If a Index Page has less that this free space, it's considered full page for new items.
            </summary>
        </member>
        <member name="M:LiteDB.IndexPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.Get(System.String)">
            <summary>
            Get a exist collection. Returns null if not exists
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.Add(System.String)">
            <summary>
            Add a new collection. Check if name the not exists
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.GetAll">
            <summary>
            Get all collections
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.Drop(LiteDB.CollectionPage)">
            <summary>
            Drop a collection - remove all data pages + indexes pages
            </summary>
        </member>
        <member name="T:LiteDB.IndexService">
            <summary>
            Implement a Index service - Add/Remove index nodes on SkipList
            Based on: http://igoro.com/archive/skip-lists-are-fascinating/
            </summary>
        </member>
        <member name="F:LiteDB.IndexService.MAX_INDEX_LENGTH">
            <summary>
            Max size of a index entry - usde for string, binary, array and documents
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.CreateIndex(LiteDB.CollectionPage)">
            <summary>
            Create a new index and returns head page address (skip list)
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.AddNode(LiteDB.CollectionIndex,LiteDB.BsonValue)">
            <summary>
            Insert a new node index inside an collection index. Flip coin to know level
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.AddNode(LiteDB.CollectionIndex,LiteDB.BsonValue,System.Byte)">
            <summary>
            Insert a new node index inside an collection index.
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.Delete(LiteDB.CollectionIndex,LiteDB.PageAddress)">
            <summary>
            Delete indexNode from a Index  ajust Next/Prev nodes
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.DropIndex(LiteDB.CollectionIndex)">
            <summary>
            Drop all indexes pages
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.GetNode(LiteDB.PageAddress)">
            <summary>
            Get a node inside a page using PageAddress - Returns null if address IsEmpty
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.FlipCoin">
            <summary>
            Flip coin - skip list - returns level node (start in 1)
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.Find(LiteDB.CollectionIndex,LiteDB.BsonValue,System.Boolean,System.Int32)">
            <summary>
            Find first node that index match with value. If not found but sibling = true, returns near node (only non-unique index)
            Before find, value must be normalized
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.FindBoundary(LiteDB.CollectionIndex,LiteDB.IndexNode,LiteDB.BsonValue,System.Int32,System.Int32)">
            <summary>
            Go first/last occurence of this index value
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Insert(LiteDB.CollectionPage,System.Byte[])">
            <summary>
            Insert data inside a datapage. Returns dataPageID that idicates the first page
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Update(LiteDB.CollectionPage,LiteDB.PageAddress,System.Byte[])">
            <summary>
            Update data inside a datapage. If new data can be used in same datapage, just update. Otherside, copy content to a new ExtendedPage
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Read(LiteDB.PageAddress,System.Boolean)">
            <summary>
            Read all data from datafile using a pageID as reference. If data is not in DataPage, read from ExtendPage. If readExtendData = false, do not read extended data 
            </summary>
        </member>
        <member name="M:LiteDB.DataService.ReadExtendData(System.UInt32)">
            <summary>
            Read all data from a extended page with all subsequences pages if exits
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Delete(LiteDB.CollectionPage,LiteDB.PageAddress)">
            <summary>
            Delete one dataBlock
            </summary>
        </member>
        <member name="M:LiteDB.DataService.StoreExtendData(LiteDB.ExtendPage,System.Byte[])">
            <summary>
            Store all bytes in one extended page. If data ir bigger than a page, store in more pages and make all in sequence
            </summary>
        </member>
        <member name="T:LiteDB.CollectionPage">
            <summary>
            Represents the collection page AND a collection item, because CollectionPage represent a Collection (1 page = 1 collection). All collections pages are linked with Prev/Next links
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.PageType">
            <summary>
            Page type = Collection
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.CollectionName">
            <summary>
            Name of collection
            </summary>
        </member>
        <member name="F:LiteDB.CollectionPage.FreeDataPageID">
            <summary>
            Get a reference for the free list data page - its private list per collection - each DataPage contains only data for 1 collection (no mixing)
            Must to be a Field to be used as parameter reference
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.DocumentCount">
            <summary>
            Get the number of documents inside this collection
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.Indexes">
            <summary>
            Get all indexes from this collection - includes non-used indexes
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.GetFreeIndex">
            <summary>
            Returns first free index slot to be used 
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.GetIndex(System.String)">
            <summary>
            Get index from field name (index field name is case sensitive) - returns null if not found
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.PK">
            <summary>
            Get primary key index (_id index)
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.GetIndexes(System.Boolean)">
            <summary>
            Returns all used indexes
            </summary>
        </member>
        <member name="F:LiteDB.CollectionIndex.INDEX_PER_COLLECTION">
            <summary>
            Total indexes per collection - it's fixed because I will used fixed arrays allocations
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Slot">
            <summary>
            Represent slot position on index array on dataBlock/collection indexes - non-persistable
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Field">
            <summary>
            Field name
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Options">
            <summary>
            Index options like unique and ignore case
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.HeadNode">
            <summary>
            Head page address for this index
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.TailNode">
            <summary>
            A link pointer to tail node
            </summary>
        </member>
        <member name="F:LiteDB.CollectionIndex.FreeIndexPageID">
            <summary>
            Get a reference for the free list index page - its private list per collection/index (must be a Field to be used as reference parameter)
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.IsEmpty">
            <summary>
            Returns if this index slot is empty and can be used as new index
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="M:LiteDB.CollectionIndex.Clear">
            <summary>
            Clear all index information
            </summary>
        </member>
        <member name="T:LiteDB.IndexOptions">
            <summary>
            A class that represent all index options used on a index creation
            </summary>
        </member>
        <member name="P:LiteDB.IndexOptions.Unique">
            <summary>
            Unique keys?
            </summary>
        </member>
        <member name="P:LiteDB.IndexOptions.IgnoreCase">
            <summary>
            Ignore case? (convert all strings to lowercase)
            </summary>
        </member>
        <member name="P:LiteDB.IndexOptions.TrimWhitespace">
            <summary>
            Remove all whitespace on start/end string?
            </summary>
        </member>
        <member name="P:LiteDB.IndexOptions.EmptyStringToNull">
            <summary>
            Convert all empty string to null?
            </summary>
        </member>
        <member name="P:LiteDB.IndexOptions.RemoveAccents">
            <summary>
            Removing accents on string?
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Position">
            <summary>
            Position of this dataBlock inside a page (store only Position.Index)
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.IndexRef">
            <summary>
            Indexes nodes for all indexes for this data block
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.ExtendPageID">
            <summary>
            If object is bigger than this page - use a ExtendPage (and do not use Data array)
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Data">
            <summary>
            Data of a record - could be empty if is used in ExtedPage
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Length">
            <summary>
            Get length of this dataBlock - not persistable
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.ExtendData">
            <summary>
            Represent data from Extend Pages - not persistable and used only when load data
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Buffer">
            <summary>
            A readonly property  (non-persistable) that contains data from this page OR from Extended Pages
            </summary>
        </member>
        <member name="T:LiteDB.IndexNode">
            <summary>
            Represent a index node inside a Index Page
            </summary>
        </member>
        <member name="F:LiteDB.IndexNode.MAX_LEVEL_LENGTH">
            <summary>
            Max level used on skip list
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Position">
            <summary>
            Position of this node inside a IndexPage - Store only Position.Index
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Prev">
            <summary>
            Pointer to prev value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Next">
            <summary>
            Pointer to next value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.KeyLength">
            <summary>
            Length of key - used for calculate Node size
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Key">
            <summary>
            The object value that was indexed
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.DataBlock">
            <summary>
            Reference for a datablock - the value
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Page">
            <summary>
            Get page reference
            </summary>
        </member>
        <member name="M:LiteDB.IndexNode.NextPrev(System.Int32,System.Int32)">
            <summary>
            Returns Next (order == 1) OR Prev (order == -1)
            </summary>
        </member>
        <member name="M:LiteDB.IndexNode.IsHeadTail(LiteDB.CollectionIndex)">
            <summary>
            Returns if this node is header or tail from collection Index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:LiteDB.IndexNode.Length">
            <summary>
            Get the length size of this node in disk - not persistable
            </summary>
        </member>
        <member name="T:LiteDB.PageAddress">
            <summary>
            Represents a page adress inside a page structure - index could be byte offset position OR index in a list (6 bytes)
            </summary>
        </member>
        <member name="T:LiteDB.ExtendPage">
            <summary>
            Represent a extra data page that contains the object when is not possible store in DataPage (bigger then  PAGE_SIZE or on update has no more space on page)
            Can be used in sequence of pages to store big objects
            </summary>
        </member>
        <member name="P:LiteDB.ExtendPage.PageType">
            <summary>
            Page type = Extend
            </summary>
        </member>
        <member name="P:LiteDB.ExtendPage.Data">
            <summary>
            Represent the part or full of the object - if this page has NextPageID the object is bigger than this page
            </summary>
        </member>
        <member name="M:LiteDB.ExtendPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="T:LiteDB.CacheService">
            <summary>
            Represent all cache system and track dirty pages. All pages that load and need to be track for
            dirty (to be persist after) must be added in this class.
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.GetPage(System.UInt32)">
            <summary>
            Get a page in my cache, first check if is in my dirty list. If not, check in my cache list. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.AddPage(LiteDB.BasePage)">
            <summary>
            Add a page to cache. if this page is in cache, override
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.SetPageDirty(LiteDB.BasePage)">
            <summary>
            Add a page as dirty page
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.Clear">
            <summary>
            Empty cache and dirty pages - returns true if had dirty pages
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.GetDirtyPages">
            <summary>
            Returns all dirty pages including header page (for better write performance, get all pages in PageID increase order)
            </summary>
        </member>
        <member name="M:LiteDB.PageService.GetPage``1(System.UInt32)">
            <summary>
            Get a page from cache or from disk (and put on cache)
            </summary>
        </member>
        <member name="M:LiteDB.PageService.SetDirty(LiteDB.BasePage)">
            <summary>
            Add a page to cache and mark them as dirty too.
            </summary>
        </member>
        <member name="M:LiteDB.PageService.GetSeqPages``1(System.UInt32)">
            <summary>
            Read all sequences pages from a start pageID (using NextPageID) 
            </summary>
        </member>
        <member name="M:LiteDB.PageService.NewPage``1(LiteDB.BasePage)">
            <summary>
            Get a new empty page - can be a reused page (EmptyPage) or a clean one (extend datafile) 
            </summary>
        </member>
        <member name="M:LiteDB.PageService.DeletePage(System.UInt32,System.Boolean)">
            <summary>
            Delete an page using pageID - transform them in Empty Page and add to EmptyPageList
            If you delete a page, you can using same old instance of page - page will be converter to EmptyPage
            If need deleted page, use GetPage again
            </summary>
        </member>
        <member name="M:LiteDB.PageService.GetFreePage``1(System.UInt32,System.Int32)">
            <summary>
            Returns a page that contains space enouth to data to insert new object - if not exits, create a new Page
            </summary>
        </member>
        <member name="M:LiteDB.PageService.AddOrRemoveToFreeList(System.Boolean,LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            Add or Remove a page in a sequence
            </summary>
            <param name="add">Indicate that will add or remove from FreeList</param>
            <param name="page">Page to add or remove from FreeList</param>
            <param name="startPage">Page reference where start the header list node</param>
            <param name="fieldPageID">Field reference, from startPage</param>
        </member>
        <member name="M:LiteDB.PageService.AddToFreeList(LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            Add a page in free list in desc free size order
            </summary>
        </member>
        <member name="M:LiteDB.PageService.RemoveToFreeList(LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            Remove a page from list - the ease part
            </summary>
        </member>
        <member name="M:LiteDB.PageService.MoveToFreeList(LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            When a page is already on a list it's more efficient just move comparing with sinblings
            </summary>
        </member>
        <member name="F:LiteDB.FileDiskService.JOURNAL_FINISH_POSITION">
            <summary>
            Position on disk to write a mark to know when journal is finish and valid (byte 19 is free header area)
            </summary>
        </member>
        <member name="F:LiteDB.FileDiskService.PAGE_TYPE_POSITION">
            <summary>
            Position, on page, about page type
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.Initialize">
            <summary>
            Open datafile - returns true if new
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.Lock">
            <summary>
            Lock datafile agains other process read/write
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.Unlock">
            <summary>
            Release lock
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.GetChangeID">
            <summary>
            Read first 2 bytes from datafile - contains changeID (avoid to read all header page)
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.ReadPage(System.UInt32)">
            <summary>
            Read page bytes from disk
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.WritePage(System.UInt32,System.Byte[])">
            <summary>
            Persist single page bytes to disk
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.TryExec(System.Action)">
            <summary>
            Try run an operation over datafile - keep tring if locked
            </summary>
        </member>
        <member name="T:LiteDB.TransactionService">
            <summary>
            Manage all transaction and garantee concurrency and recovery
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.Begin">
            <summary>
            Starts a new transaction - lock database to garantee that only one processes is in a transaction
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.Commit">
            <summary>
            Commit the transaction - increese 
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.AvoidDirtyRead">
            <summary>
            This method must be called before read/write operation to avoid dirty reads.
            It's occurs when my cache contains pages that was changed in another process
            </summary>
        </member>
        <member name="T:LiteDB.IndexNotFoundException">
            <summary>
            A specific exception when a query didnt found an index
            </summary>
        </member>
        <member name="T:LiteDB.LiteDatabase">
            <summary>
            The LiteDB database. Used for create a LiteDB instance and use all storage resoures. It's the database connection
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(System.String)">
            <summary>
            Starts LiteDB database using a connectionString for filesystem database
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(System.IO.Stream)">
            <summary>
            Initialize database using any read/write Stream (like MemoryStream)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(LiteDB.IDiskService,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using full parameters
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection``1(System.String)">
            <summary>
            Get a collection using a entity class as strong typed document. If collection does not exits, create a new one.
            </summary>
            <param name="name">Collection name (case insensitive)</param>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection(System.String)">
            <summary>
            Get a collection using a generic BsonDocument. If collection does not exits, create a new one.
            </summary>
            <param name="name">Collection name (case insensitive)</param>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollectionNames">
            <summary>
            Get all collections name inside this database.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.CollectionExists(System.String)">
            <summary>
            Checks if a collection exists on database. Collection name is case unsensitive
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.DropCollection(System.String)">
            <summary>
            Drop a collection and all data + indexes
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.RenameCollection(System.String,System.String)">
            <summary>
            Rename a collection. Returns false if oldName does not exists or newName already exists
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.FileStorage">
            <summary>
            Returns a special collection for storage files/stream inside datafile
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Shrink">
            <summary>
            Reduce datafile size re-creating all collection in another datafile - return how many bytes are reduced.
            </summary>
        </member>
        <member name="F:LiteDB.BasePage.PAGE_SIZE">
            <summary>
            The size of each page in disk - 4096 is NTFS default
            </summary>
        </member>
        <member name="F:LiteDB.BasePage.PAGE_HEADER_SIZE">
            <summary>
            This size is used bytes in header pages 17 bytes (+3 free) = 20 bytes
            </summary>
        </member>
        <member name="F:LiteDB.BasePage.PAGE_AVAILABLE_BYTES">
            <summary>
            Bytes avaiable to store data removing page header size - 4076 bytes
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.PageID">
            <summary>
            Represent page number - start in 0 with HeaderPage [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.PageType">
            <summary>
            Indicate the page type [1 byte] - Must be implemented for each page type
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.PrevPageID">
            <summary>
            Represent the previous page. Used for page-sequences - MaxValue represent that has NO previous page [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.NextPageID">
            <summary>
            Represent the next page. Used for page-sequences - MaxValue represent that has NO next page [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.ItemCount">
            <summary>
            Used for all pages to count itens inside this page(bytes, nodes, blocks, ...) [2 bytes]
            Its Int32 but writes in UInt16
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.FreeBytes">
            <summary>
            Used to find a free page using only header search [used in FreeList] [2 bytes]
            Its Int32 but writes in UInt16
            Its updated when a page modify content length (add/remove items)
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.IsDirty">
            <summary>
            Indicate that this page is dirty (was modified) and must persist when commited [not-persistable]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.DiskData">
            <summary>
            This is the data when read first from disk - used to journal operations (IDiskService only will use)
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.UpdateItemCount">
            <summary>
            Every page must imeplement this ItemCount + FreeBytes
            Must be called after Items are updates (insert/deletes) to keep variables ItemCount and FreeBytes synced
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.CreateInstance``1(System.UInt32)">
            <summary>
            Create a new instance of page based on T type
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.CreateInstance(System.UInt32,LiteDB.PageType)">
            <summary>
            Create a new instance of page based on PageType
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.ReadPage(System.Byte[])">
            <summary>
            Read a page with correct instance page object. Checks for pageType
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.WritePage">
            <summary>
            Write a page to byte array
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.PageType">
            <summary>
            Page type = Header
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.CHANGE_ID_POSITION">
            <summary>
            ChangeID in file position (can be calc?)
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.HEADER_INFO">
            <summary>
            Header info the validate that datafile is a LiteDB file (27 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.FILE_VERSION">
            <summary>
            Datafile specification version
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.ChangeID">
            <summary>
            Get/Set the changeID of data. When a client read pages, all pages are in the same version. But when OpenTransaction, we need validade that current changeID is the sabe that we have in cache
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.FreeEmptyPageID">
            <summary>
            Get/Set the pageID that start sequenece with a complete empty pages (can be used as a new page)
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.LastPageID">
            <summary>
            Last created page - Used when there is no free page inside file
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.FirstCollectionPageID">
            <summary>
            Get/Set the first collection pageID (used as Field to be passed as reference)
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.UserVersion">
            <summary>
            Get/Set a user version of database file
            </summary>
        </member>
        <member name="M:LiteDB.HeaderPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="T:LiteDB.ConnectionString">
            <summary>
            Manage ConnectionString to connect and create databases. Connection string are NameValue using Name1=Value1; Name2=Value2
            </summary>
        </member>
        <member name="M:LiteDB.ConnectionString.GetFileSize(System.String,System.Int64)">
            <summary>
            Get a value from a key converted in file size format: "1gb", "10 mb", "80000"
            </summary>
            <param name="key"></param>
            <param name="defaultSize"></param>
            <returns></returns>
        </member>
        <member name="T:LiteDB.MimeTypeConverter">
            <summary>
            Convert filename to mimetype (http://stackoverflow.com/questions/1029740/get-mime-type-from-filename-extension)
            </summary>
        </member>
        <member name="T:LiteDB.LiteException">
            <summary>
            The main exception for LiteDB
            </summary>
        </member>
        <member name="T:LiteDB.Logger">
            <summary>
            A logger class to log all information about database. Used with levels. Level = 0 - 255 
            All log will be trigger before operation execute (better for log)
            </summary>
        </member>
        <member name="P:LiteDB.Logger.Level">
            <summary>
            To full logger use Logger.FULL or any combination of Logger constants like Level = Logger.ERROR | Logger.COMMAND | Logger.DISK
            </summary>
        </member>
        <member name="F:LiteDB.Logger.Output">
            <summary>
            Output function to write log - default is log in console
            </summary>
        </member>
        <member name="M:LiteDB.Logger.Write(System.Byte,System.String,System.Object[])">
            <summary>
            Write log text to output using inside a component (statics const of Logger)
            </summary>
        </member>
        <member name="T:LiteDB.StringScanner">
            <summary>
            A StringScanner is state machine used in text parsers based on regular expressions
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.#ctor(System.String)">
            <summary>
            Initialize scanner with a string to be parsed
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Reset">
            <summary>
            Reset cursor position
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Seek(System.Int32)">
            <summary>
            Skip cursor position in string source
            </summary>
        </member>
        <member name="P:LiteDB.StringScanner.HasTerminated">
            <summary>
            Indicate that cursor is EOF
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Scan(System.String)">
            <summary>
            Scan in current cursor position for this patterns. If found, returns string and run with cursor
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Scan(System.Text.RegularExpressions.Regex)">
            <summary>
            Scan in current cursor position for this patterns. If found, returns string and run with cursor
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Scan(System.String,System.Int32)">
            <summary>
            Scan pattern and returns group string index 1 based
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Match(System.String)">
            <summary>
            Match if pattern is true in current cursor position. Do not change cursor position
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Match(System.Text.RegularExpressions.Regex)">
            <summary>
            Match if pattern is true in current cursor position. Do not change cursor position
            </summary>
        </member>
    </members>
</doc>
